#include <Adafruit_NeoPixel.h>

//Code by Daniel Near
// 09-21-2013

#define PIN 6//digital out to neopixel strip
#define PIXELS 90
#define PATTERN_SIZE 18
#define DELAY 32
//r=0x1,0x2, g=0x4,0x8, b=0x10,0x20
byte aztekpattern[12][18]={//array image to display, 18 pixels with 12 scan lines
  { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x11,0x11,0x12,0x13,0x13  },
  { 0x00,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x13  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x24,0x00,0x00,0x00,0x31,0x00,0x32,0x00,0x33  },
  { 0x00,0x08,0x00,0x08,0x08,0x08,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33  },
  { 0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x33  },
  { 0x00,0x0C,0x0C,0x0C,0x0C,0x0C,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  },
  { 0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x0d,0x00,0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x33  },
  { 0x00,0x08,0x00,0x08,0x08,0x08,0x00,0x00,0x0e,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33  },
  { 0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x31,0x00,0x32,0x00,0x33  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x13  };


byte aztekpattern2[18][18]={//array image to display, 18 pixels with 12 scan lines
  { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x11,0x11,0x12,0x13,0x13  },
  { 0x00,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x13  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x24,0x00,0x00,0x00,0x31,0x00,0x32,0x00,0x33  },
  { 0x00,0x08,0x00,0x08,0x08,0x08,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33  },
  { 0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x33  },
  { 0x00,0x0C,0x0C,0x0C,0x0C,0x0C,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  },
  { 0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x0d,0x00,0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x33  },
  { 0x00,0x08,0x00,0x08,0x08,0x08,0x00,0x00,0x0e,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33  },
  { 0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x31,0x00,0x32,0x00,0x33  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x21,0x21,0x22,0x00,0x23  },
  { 0x00,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x13  };
// Parameter 1 = number of pixels in strip
// Parameter 2 = pin number (most are valid)
// Parameter 3 = pixel type flags, add together as needed:
//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)
//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)
//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)
//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)
Adafruit_NeoPixel strip = Adafruit_NeoPixel(90, PIN, NEO_GRB + NEO_KHZ800);
int frame = 0;
void setup() {
  strip.begin();
  strip.show(); // Initialize all pixels to 'off'
}

void loop() {
  // Some example procedures showing how to display to the pixels:
  render_frame(frame);
  frame++;
  frame = frame%12;
  delay(DELAY);
}
void render_frame(int frame)
{
    for(int16_t i=0;i<PATTERN_SIZE;i++)
    {

      for(int16_t offset=0; offset < PIXELS; offset+=PATTERN_SIZE){
        strip.setPixelColor(i+offset,replaceColor(aztekpattern[frame][i]));
      }
    }
    strip.show(); // push out to strip
 
}
unsigned long replaceColor(byte color)//extend 2 bits to 24 and shift bits for brighter shades

{
switch (color&0x03)//red{//mask off the 2 relevant bits and expand to 8 bits
  case 0x01:
    redcolor=0x0F;
    break;
  case 0x02:
    redcolor=0xF0;
    break;
  case 0x03:
    redcolor=0xFF;
    break;
  default:redcolor=0x00;
  }
switch (color&0x0C)//grn{
  case 0x04:
    grncolor=0x0F;
    break;
  case 0x08:
    grncolor=0xF0;
    break;
  case 0x0C:
    grncolor=0xFF;
    break;
  default:grncolor=0x00;
  }
switch (color&0x30)//blu{
  case 0x10:
    blucolor=0x0F;
    break;
  case 0x20:
    blucolor=0xF0;
    break;
  case 0x30:
    blucolor=0xFF;
    break;
  default:blucolor=0x00;
  }
  
  //byte redcolor=((color & 0x02)<<6)|((color&0x01)<<5);
  //byte grncolor=((color & 0x08)<<4)|((color&0x04)<<3);
  //byte blucolor=((color & 0x30)<<2)|((color&0x04)<<1);//<<1;
  return strip.Color(redcolor,  grncolor,  blucolor);//combine individual 8 bit RGB values to a long

}
// Fill the dots one after the other with a color




